# Import the necessary libraries
from PIL import Image as im
import numpy as np
from scipy import signal
sig = np.repeat([0., 1., 0.], 100)
win = signal.windows.hann(50)

img = im.open('test.jpeg') # load image
A = np.array(img)

#Agrey = A[:,:,0]* 0.33 + A[:,:,1] * 0.33 + A[:,:,2] * 0.33 # equal weights
B = A[:,:,0]*0.2989 + A[:,:,1]*0.5870 + A[:,:,2]*0.1140 # converts to grey scale

def threshold(arr,thresh):
    out = np.zeros(arr.shape)
    out[arr >= thresh] = 1
    return out

B = threshold(B,200) # threshold
Bthresh = B

# edge detect
win = np.array([[-1,1],[0,0]]) # window
Bv = signal.convolve(B, win, mode='same') # convolve verticaly
Bh = signal.convolve(B,np.transpose(win),mode = 'same') # convolve horizontaly
B = np.absolute(Bv) + np.absolute(Bh)
B = threshold(B,1)

# circle function
def circle(r):
    # Calculate the size of the square array
    r = r+1
    size = (2 * r + 1, r+1)
    
    print(size)

    # Create an empty square array of zeros
    arr = np.zeros((size[0], size[1]), dtype=int)
    
    for x in np.arange(size[0])-r:
        y = round(np.sqrt(r*r - x*x))
        arr[x+r,y] = 1
    
    for x in np.arange(size[0]-2)-(r-1):
        y = round(np.sqrt((r-1)*(r-1) - x*x))
        arr[x+r,y] = 1

    arr = np.concatenate((np.flip(arr),arr[:,1:] ), axis=1 ) 
    arr = arr + np.transpose(arr)
    arr[arr > 0] = 1
    return arr


win = circle(25)
Bmid = signal.convolve(B,win,mode = 'same')
Bmid[Bthresh == 1] = 0 # get rid of things outside of og threshold image
print(np.sum(win))
Bmid = threshold(Bmid,25)

# normalizes and converts back to color so .save() doesn't freak out
red = B
red = np.around(((red-np.amin(red))/np.amax(red))*255) # normalize between 0 and 255
red = red.astype(np.uint8) # cast into proper data type

blue = Bmid
blue = np.around(((blue-np.amin(blue))/np.amax(blue))*255) # normalize between 0 and 255
blue = blue.astype(np.uint8) # cast into proper data type



output = np.dstack((blue,blue,red))
# save
data = im.fromarray(output) # creating image object of array
data.save('testProcessed.png') # saving the final output 


# what is happening right now is that although i can exclude poitns after the circle convolutiont that lie outside of the initial bitmap, the convolution still goes through those points and generates high intensity results that came from outside of the bit mask but are mapped to inside the bit mask resulting in points generated by things we don't want. could solve this by writing a custom convolution algorithm.... probably would be slow but like we only gotta do it on one image, it aint that big... could be doable